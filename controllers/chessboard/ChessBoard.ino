// Copyright (c) 2025 Vipin M
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

#include "Utils.h"
#include "Sensor.h"
#include "Display.h"
#include "Button.h"
#include "Serial.h"
#include "Mock.h"

move_state_t state;
char legal_moves[LEGAL_MOVES_MAX][5];
uint8_t legal_moves_cnt;
char check_squares[CHECK_SQUARES_MAX][3];
uint8_t check_squares_cnt;
char special_moves[MOVE_TYPE_MAX][5];
bool confirm, hint;
uint8_t hint_override_cnt = 0;
unsigned long prev_override_ms = 0;
uint8_t confirm_zreset_cnt = 0;
unsigned long prev_zreset_ms = 0;

bool mock_mode = MOCK_MODE_DEFAULT;
unsigned long mock_move_start_time = 0;
unsigned long mock_move_duration = 0;
bool mock_move_in_progress = false;
bool mock_hint_requested = false;
char mock_selected_move[5] = "";
bool mock_occupancy[CHESS_ROWS][CHESS_COLS];

void process_board() {
  if (state == MOVE_RESET) {
    confirm = false;
    hint = false;

    // In mock mode, automatically transition to MOVE_START
    if (mock_mode) {
      Serial.println("MOCK: Transitioning to MOVE_START");
      Serial.flush();
      state = MOVE_START;
    }
  } else if (state == MOVE_START) {
    // Mock mode: Start automated move if not already in progress
    if (mock_mode && !mock_move_in_progress && !hint) {
      mock_start_move();
    }

    // Mock mode: Check if move is complete
    if (mock_mode) {
      mock_check_move_complete();
    }

    // Need clue?
    if (hint) {
      hint = false;
      highlight_move(special_moves[MOVE_TYPE_HINT], MAGENTA, MAGENTA);
      if (!mock_mode) {
        delay(500);
      } else {
        Serial.println("MOCK: Hint displayed");
      }

      // Detect user override
      unsigned long curr_override_ms = millis();
      if (hint_override_cnt == 0 || curr_override_ms - prev_override_ms <= HINT_OVERRIDE_INTERVAL) {
        hint_override_cnt++;
        prev_override_ms = curr_override_ms;  // Reset the timer
        if (hint_override_cnt == HINT_OVERRIDE_CNT) {
          state = MOVE_STOP;
          hint_override_cnt = 0;
          legal_moves_cnt = 0;
          reset_occupancy();
          send_response("ffff");
        }
      } else {
        hint_override_cnt = 1;
        prev_override_ms = curr_override_ms;
      }
    }

    // Display if the user is in check
    if (check_squares_cnt) {
      reset_display();
      uint8_t row, col;
      xy_lookup(check_squares[0], row, col);
      update_display(row, col, ORANGE);
      for (int i=1; i<check_squares_cnt; i++) {
        xy_lookup(check_squares[i], row, col);
        update_display(row, col, GREEN);
      }
      lightup_display();
      delay(5000);
      check_squares_cnt = 0;
    }
  }
  
  // Move finalized?
  if (confirm) {
    confirm = false;
    if (state == MOVE_START) {
      char move[5];
      bool move_valid = false;

      if (mock_mode) {
        // In mock mode, use the selected move directly
        strncpy(move, mock_selected_move, 4);
        move[4] = '\0';
        move_valid = true;
        Serial.print("MOCK: Confirming move ");
        Serial.println(move);
        Serial.flush();
      } else {
        // In real mode, compute move from sensors
        move_valid = compute_move(move);
      }

      if (move_valid) {
        send_response(move);
        state = MOVE_STOP;
        legal_moves_cnt = 0;
        check_squares_cnt = 0;
        reset_occupancy();
        set_control_pixel(HUMAN, BLACK);
        set_control_pixel(COMPUTER, GREEN);
      } else {
        state = MOVE_RESET;
        unsigned long curr_zreset_ms = millis();
        if (confirm_zreset_cnt == 0 || curr_zreset_ms - prev_zreset_ms <= CONFIRM_ZRESET_INTERVAL) {
          confirm_zreset_cnt++;
          prev_zreset_ms = curr_zreset_ms;  // Reset the timer
          if (confirm_zreset_cnt == CONFIRM_ZRESET_CNT) {
            confirm_zreset_cnt = 0;
          }
        } else {
          confirm_zreset_cnt = 1;
          prev_zreset_ms = curr_zreset_ms;
        }
      }
    } else if (state == MOVE_COMP) {
      // TODO: For now, we will just send the ACK assuming the player 
      // moving the pieces on behalf of the computer is doing the right 
      // thing. Eventually, the move should be generated by sensing the board
      send_response(special_moves[MOVE_TYPE_COMP]);
      state = MOVE_STOP;
    } else if (state == MOVE_OVERRIDE) {
      send_response(special_moves[MOVE_TYPE_OVERRIDE]);
      state = MOVE_STOP;
      set_control_pixel(HUMAN, BLACK);
      set_control_pixel(COMPUTER, GREEN);
    } else if (state == MOVE_CHECKMATE) {
      display_win(special_moves[MOVE_TYPE_CHECKMATE]);
      state = MOVE_INIT;
      reset_display();
      lightup_display();
    }
  }
}

void debug_init() {
  Serial.begin(9600);
  for (uint16_t trial = 0; trial < 2000; trial++) {
      if (Serial) {
        break;
      }
  }

  // Initialize random seed
  randomSeed(analogRead(0));

  if (DEBUG_ENABLED) {
    Serial.print("INIT: Default mode is ");
    Serial.println(mock_mode ? "MOCK" : "REAL");
    Serial.println("INIT: Mode can be changed via 'mode:real' or 'mode:mock' command");
  }
}

void setup() {
  debug_init();
  serial_init();
  display_init();

  if (!mock_mode) {
    sensor_init();
    button_init();
  } else {
    if (DEBUG_ENABLED) {
      Serial.println("MOCK: Skipping sensor and button initialization");
    }
  }

  state = MOVE_NONE;
  if (DEBUG_ENABLED) {
    Serial.println("Welcome to ChessMate!");
  }
}

void loop() {
  scan_serial();

  if (!mock_mode) {
    scan_sensors();
    scan_buttons();
  }

  process_board();
}
